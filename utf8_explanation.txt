הקדמה: הקידוד ASCII שהומצא עבור מיפוי של אותיות באנגלית הוא ייצוג ע""פ 7 ביטים, ולאחר מכן בוצעה הרחבה לקידוד ל-8 סיביות. אך במיפוי הזה יש מספר מועט של תוים ואין אפשרות לקודד בו תוים של שפות אחרות (מלבד אנגלית ואפשרות לעוד שפה ע"י הסיבית השמינית). ולכן עבור כך הומצא המיפוי של Unicode הבנוי משני Bytes וכך אם רוצים לקודד תווי ASCII משתמשים רק ב-Byte הראשון ולייצוג רחב יותר משתמשים ב-Byte השני. אך גם בקידוד הזה צצו בעיות, לדוגמה: גודל הקבצים שנכתבו עד אז באנגלית ע"י ASCII, כעת הוכפל גודלם. ובעיה לא פחות חמורה שאין לו תאימות לאחור, כלומר הוא אינו תומך בקבצים ישנים שנכתבו על פי הקידוד הבסיסי של ASCII (ב-Byte בודד).

כעת נעבור ל-UTF-8: עקב הרצון לקודד מגוון רחב של שפות ובאופן חסכוני שלא יגדיל את גודל הקבצים באין צורך, הומצא הקידוד UTF-8. הקידוד UTF-8 הוא שיטה לקידוד תוים ולא סתם מיפוי של תוים למחרוזת של ביטים. הרעיון של UTF-8 הוא שאין לו מספר קבוע של בתים לקידוד התווים אלא מספר הבתים בו משתנה, תו ב-UTF-8 יכול להיות מיוצג בין Byte לארבעה Bytes. לכן יש לו תאימות לאחור והוא תומך במיפוי של טבלת ASCII, ע"י קידוד UTF-8 ב-Byte בודד. ולכן אם קובץ נכתב רק באנגלית גודלו לא יצטרך לגדול מעבר לגודל של Byte עבור כל תו. ובכלל עבור שאר השפות: כיוון שגודל הבתים משתנה, לכן כל שפה שניתן לייצג אותה במעט בתים, הקובץ שנכתב בשפה יהיה בגודל המינימלי עבורו ולא יהיו בתים מיותרים. וכך ניתן לקודד תוים של שפות רבות אך עם חסכון בגודל הקובץ. בנוסך כיוון שתוים באנגלית מקודדים באותו אופן הן בקובץ שך ASCII והן בקובץ UTF-8 לכן הקידוד של UTF-8 יכול לפענח קבצים שנכתבו ב-ASCII ולכן יש תאימות לאחור.

הבעיה היא שפותחים קובץ שמקודד ב-UTF-8 המחשב צריך לדעת בכמה Bytes מיוצג כל תו (שהרי זהו דבר שמתשנה). לשם כך יש שיטה מסויימת איך לדעת כמה בתים מיוצג תו עבור קובץ מסויים שנפתח. וזה מבוצע באופן הבא:
אם  ה-MSB ב-Byte הוא 0 אזי הקידוד עבור התו הנוכחי הוא ASCII שמקודד ב-Byte אחד.
אחרת - אם יש 1 ב-MSB של ה-Byte - זהו לא קידוד ASCII . וכדי לדעת בכמה תווים תשתמש אזי עבור כל תו, בבית הראשון מספר האחדות שיהיו ב-MSB יסמנו בכמה בתים מקודד התו הנוכחי ולאחר מכן יבוא 0, ובנוסף כל בית ששיך לאותו התו ה-MSB שלו יתחיל ב-10. כך למשל בשימוש בשני בתים יש הבסיס איתו יקודדו את התו יהיו שני בתים שיראו כך 110xxxxx 10xxxxxx, ולכן עבור שני בתים נשארות רק אחד עשר סיביות ליצג את התו (במקום המסומן ע"י תוי x). ובסך הכול כך ניתן לדעת באיזה אופן לקרוא את הבתים שבקובץ. 

כמה נקודות חשובות על הקידוד:
1. השפות עם השימוש הגבוה יותר מקודדות במספר קטן יותר של Bytes. לכן רוב השפות השימושייות כיום כולל עברית מקודדות בשני Bytes. שזה המינימום לקידוד שפה שאינה אנגלית. מכאן שגודל הקבצים עבור שפות שימושיות קטן באופן יחסי. יש לציין הקידוד היחיד ב-UTF-8 שמשתמש בבית בודד הוא הקידוד של ASCII.
2. כאשר יש צורך לקודד טקסט ב-UTF-8, ראשית המחשב ממפה כל תו לייצוג שלו לפי Unicode, ולאחר מכן המחשב לוקח את המיפוי הזה ומתאים אותו לקידוד של UTF-8. באופן דומה, כאשר המחשב מקבל קובץ עם קידוד UTF-8 הוא לוקח את הקידוד ומתאים כל תו למפוי שלו ב-Unicode, ואז מציג את התווים במחשב. כל הרעיון כאן שהמיפוי של התווים הוא לפי Unicode אך הקידוד הוא שונה כפי שהוסבר למעלה (גודל משתנה של Bytes ועוד התאמות).

סך הכול: כל תו ב-UTF-8 מקודד במספר המינימלי של ה-Bytes שצריך ואין אף תו שיש בו בית ללא שימוש, כך חוסכים בגודל הקבצים ומשתמשים בתאימות לאחור.